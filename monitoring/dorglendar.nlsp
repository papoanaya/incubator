; Calendar with Emacs org-mode agenda for  DZen2
; Inspired by and contributed from the org-awesome module, copyright of Damien Leone 
; and Alexander Yakushev 
; Licensed under GPLv2
; @author Luis R. Anaya

(context 'orglendar)

(set 'files '())
(set 'char-width nil)
(set 'text_color  "#FFFFFF")
(set 'today_color  "#00FF00")
(set 'event_color  "#FF0000")
(set 'font  "monospace 8")
(set 'parse_on_show true)
(set 'calendar_width  21)
(set 'limit_todo_length  nil)

(set 'calendar nil)
(set 'todo nil)
(set 'offset 0)
(set 'data nil)


(define (pop_spaces s1,s2,maxsize)
  (let ((sps ""))
    (for (i 1 (- maxsize (length s1) (length s2)))
	 (begin 
	   (set 'sps (append sps " "))))
    (append s1 sps (string s2))))


(define (parse_agenda)
  (let ((today (date (date-value) 0 "%Y-%m-%d"))
	(task_name "")
	(tasks '())
	(dates '())
	(maxlen 20))
    (setq data (list tasks dates maxlen))
   ; what is files?
    
    (setq files '("crap.org"))

    (dolist (file files)

      (set 'fd (open file "r"))
      (if (nil? fd)
	  (println (format "W: orglendar: cannot find  %s" file))
	  (begin
	    (while (setq line (read-line fd))
		    (setq scheduled (find "SCHEDULED:" line))
		    (setq closed (find "CLOSED:" line))
		    (setq deadline (find "DEADLINE" line))
		    (if (or (and scheduled (not closed))
			    (and deadline (not closed)))
			(begin
			   (setq re (regex {(\d\d\d\d)-(\d\d)-(\d\d)} line))
			   (setq y $1)
			   (setq m $2)
			   (setq d $3)

			   (setq task_date (append y "-" m "-" d))

			   (if (and d task_name (>= task_date today))
			       (let ((find_begin "")
				     (task_start (find "[A-Z]+\s+" task_name))

				     (if (and task_start  (= find_begin 1))
					 (setq task_name (slice task_name, task_start+1)))

				     (setq tasks (find "\s+(:.+):" task_name))
				     (setq task_end $0)
				     (setq task_tags $2)

				     (if task_tags 
					 (setq task_name (slice task_name 1 (- task_end 1)))
					 (setq task_tags " "))
  
				     (setq len (+ (length task_name) (length task_tags)))
				     
				     ; Adjust Max Length (position 2 of the list)

				     (if (and (> len (nth 2 data))
					      (>= task_date today))
					 (setq (nth 2 data) len))
				     
				     ; Push items to the tasks list, on the first of the data.

				     (push (list task_name tags task-date) (nth 0 data))
				     (push (cons (list y (int m) (int d)) true) (nth 1 data)) )))
			   )
					 
			(setq task_name (find "%*+%s+(.+)" line))) )) )) )

  (println data)
)

;   table.sort(data.tasks, function (a, b) return a.date < b.date end)



(define (create_calendar)
  (let ((offset (or offset 0))
        (right-now (date (date-value) 0 "*t"))
        (cal_month (nth 1 (now)))
        (cal_year (nth 0 (now))))
    
	(cond 
	 ((> cal_month 12)
	  (setq cal_month (mod cal_month 12))
	  (setq cal_year (+ cal_year 1)))
	 ((< cal_month 1)
	  (setq cal_month (+ cal_month 12))
	  (setq cal_year (- cal_year 1))) )

	(setq cal_output 
          (exec (format "cal  %d %d"
                        cal_month
                        cal_year)))
    
    (setq last_days
          (map
           (fn (w)
             (let ((w-list  (parse w)))
               (when w-list (last w-list))))
           cal_output))

	(setq last_day    (int (last (filter string? last_days))))
	(setq first_day (date-value  cal_year  cal_month 1))


	(setq first_day_in_week (int  (date first_day 0 "%w")))

	(setq result " Su Mo Tu We Th Fr Sa\n")
	(dotimes (i first_day_in_week)
              (setq result (append result (format "%3s" " "))))

	(for (day 1 last_day)
	     (let ((last_in_week (= (mod (+ day first_day_in_week) 7) 0))
               (day_str (format "%3s" (string day))))

;; (append (pop_spaces "", day, 2)
;;         (and (string last_in_week ) 
;;              (or "" " ")))

	       (cond
            ((and (= cal_month (nth 1 (now)))
                  (= cal_year (nth 0 (now)))
                  (= day  (nth 2 (now))))
             (begin
               (setq this_month nil)
               (setq result (append result "^fg(yellow)" day_str "^fg()")))) ;needs to be made bold 

            ;;(nth 1 data)  List must be the data
            ;; ((find-all (append (string cal_year) (string cal_month) (string day)) '() )  
            ;;  (setq result (append result day_str))) ;needs to be made bold 

            (true
             (setq result (append result day_str))))

	       (if (or last_in_week 
                    (= (string day) (string last_day)))
               (setq result (append result "\n"))))) 

	(setq header "")

	(if this_month 
	    (setq header (date (date-value) 0 "%a, %d %b %Y"))
	    (setq header (date first_day 0 "%B %Y")))
	
    
	(append header "\n" result)

;;   (! (append "echo \"" result "\"| dzen2 -p 50 -x 400 -y 60 -w 160 -l 5 -ta l -sa l"))

))
 

(define (create_todo)
  (let ((result "")
        (maxlen = (+ data.maxlen 3))

        (if (and limit_todo_length  
                 (< limit_todo_length max_len))
            (setq maxlen limit_todo_length))
        (let (prev_date limit tname)

          (dolist (tasks  data.tasks)
                  (if (find prev_date tasks.date)
                      (setq result (append result task.date ) ))
                  (setq tname task.name)
                  (setq limit (- maxlen (length task.tags) 3))
                  (if (< limit (length tname))
                      (setq tname (slice tname 1 (- limit 3))))
                  (setq result (append result (pop_spaces tname, task.tags, maxlen)))
                  (if (find i data.tasks)
                      (setq result (append result "\n"))))
          (if (= result "" ) " "
              (font text_color result data))))))


(define (get_calendar_and_todo_text pm-offset)
  (if (or parse_on_show (not data))
      (parse_agenda))
  (setq offset pm-offset)

  (let ((header nil )
        (cal create_calendar))
    (create_todo)))


;; DZEN2 Specific Comes Here



(context MAIN)
